Authors- Vimanyu Saxena, Paul Holbel

Question 1) The new files created were: BSTNodeInt.o and testBST.o

Question 2)

Error-
[cs100sdl@ieng6-201]:~:22$ make bst
g++      -g -Wall -std=c++11 -c BSTInt.cpp
BSTInt.cpp: In function 'bool insert(int)':
BSTInt.cpp:25:8: error: 'root' was not declared in this scope
   if (!root) {
        ^
BSTInt.cpp:27:7: error: 'isize' was not declared in this scope
     ++isize;
       ^
BSTInt.cpp:31:22: error: 'root' was not declared in this scope
   BSTNodeInt* curr = root;
                      ^
BSTInt.cpp:56:5: error: 'isize' was not declared in this scope
   ++isize;
     ^
make: *** [BSTInt.o] Error 1

Explanation:
This happens because insert is a method that is defined in the BSTInt class. 
When we use "bool BSTInt::insert(int item)", we use that method that is 
already defined. But when we use "bool insert(int item)",we are not accessing
that defined method and hence we get an error.


Question 3)

The bug was in the function "insert". It would just insert the first three 
elements properly as it had an "and" condition for the nodes to have
both the left and right childs to change the value of the "curr" node. 

Question 4)

We spotted the error by just looking at the code as we could realise that
it wasn't properly inserting after 4 or 5 "insert" calls. By looking at the 
code, we realised that the "curr" node wasn't changing becuase of the "and"
condition in the "while" loop. So, we decided to change that to an "or"
condition and checked to change the value of "curr" node only when there
was a node present. If not, we would break out of the loop and make a new
node outside which will have "item" as its data value. With these steps, we
ensured that all the values inserted will be properly added to the tree. 
Another change we did was to see if values that already belong to the tree
are being added again. If this was happening, we would make the "insert" 
function return false. As the earlier code wasn't checking for this obvious
condition, it was easy to detect it by just looking at the code.    


Question 5)

For BSTInt.h: It's pass by value. This is because we want to create a new 
              object when inserting.

For BST.hpp: It's pass by reference. This is because we don't want to 
             create a new object when inserting.



Question 6)

Sorted input produces taller trees.


Question 7)

For sorted input: We expect to get a tree of height N as all the input numbers 
                  will be in one direction either left or right based on the
                  way the sorted order is.

For random input: We expect to get a tree of height N/2. This will all be in 
                  a random manner and the average height of all these random
                  orders may come out to be N/2.

Results:

For sorted input: As expected, the height of the tree when we input all the 
                  numbers from 1 to 10 in a sorted manner is 10 so the size
                  is N and the expectations have matched.

For random input: As expected, after doing it for many random orders, the 
                  average height was somewhere near 5 for numbers 1 to 10.
                  So the expectations have matched.















